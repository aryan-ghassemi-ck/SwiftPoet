//
//  CodeWriter.swift
//  SwiftPoet
//
//  Created by Kyle Dorman on 11/10/15.
//
//

import Foundation

public typealias Appendable = String.CharacterView

public class CodeWriter {
    private var _out: Appendable
    public var out: String {
        return String(_out)
    }

    private var indentLevel: Int

    public init(out: Appendable = Appendable(""), indentLevel: Int = 0) {
        self._out = out
        self.indentLevel = indentLevel
    }
}

// MARK: Indentation
public extension CodeWriter {
    public func indent() -> CodeWriter {
        return indent(1)
    }

    public func indent(levels: Int) -> CodeWriter {
        return indentLevels(levels)
    }

    public func unindent() -> CodeWriter {
        return unindent(1)
    }

    public func unindent(levels: Int) -> CodeWriter {
        return indentLevels(-levels)
    }

    private func indentLevels(levels: Int) -> CodeWriter {
        indentLevel = max(indentLevel + levels, 0)
        return self
    }
}

extension CodeWriter {
    //
    //  FileName.swift
    //  Framework
    //
    //  Contains:
    //  PoetSpecType PoetSpecName
    //  PoetSpecType2 PoetSpecName2
    //
    //  Created by SwiftPoet on MM/DD/YYYY
    //
    //
    public func emitFileHeader(fileName: String?, framework: String?, specs: [PoetSpec]) {
        let specStr: [String] = specs.map { spec in
            return headerLine("\(spec.construct.stringValue) \(spec.name)")
        }

        var header: [String] = [headerLine()]
        if let fileName = fileName {
            header.append(headerLine("\(fileName).swift"))
        }
        header.append(headerLine())
        if let framework = framework {
            header.append(headerLine(framework))
            header.append(headerLine())
        }

        if !specStr.isEmpty {
            header.append(headerLine("Contains:"))
            header.appendContentsOf(specStr)
            header.append(headerLine())
        }

        header.append(headerLine(generatedByAt()))
        header.append(headerLine())
        header.append(headerLine())
        
        _out.appendContentsOf(header.joinWithSeparator("\n").characters)
        self.emitNewLine()
        self.emitNewLine()
    }

    private func headerLine(str: String? = nil) -> String {
        guard let str = str else {
            return "//"
        }
        return "//  \(str)"
    }

    private func createdAt() -> String {
        let formatter = NSDateFormatter()
        formatter.dateStyle = .ShortStyle
        return formatter.stringFromDate(NSDate())
    }

    private func generatedByAt() -> String {
        return "Generated by SwiftPoet on \(createdAt())"
    }

    public func emitImports(imports: Set<String>) {
        if (imports.count > 0) {
            let importString = imports.joinWithSeparator("\nimport ")
            _out.appendContentsOf("import ".characters)
            _out.appendContentsOf(importString.characters)
            _out.appendContentsOf("\n\n".characters)
        }
    }

    public func emitDocumentation(o: AnyObject) {
        if let spec = o as? TypeSpec, let docs = spec.description {
            var specDoc = "" as String

            let firstline = String.indent("/**\n", i: indentLevel)
            let lastline = String.indent("*/\n", i: indentLevel)
            let indentedDocs = String.indent(docs + "\n", i: indentLevel + 1)

            specDoc.appendContentsOf(firstline)
            specDoc.appendContentsOf(indentedDocs)
            specDoc.appendContentsOf(lastline)
            _out.appendContentsOf(specDoc.characters)
        } else if let spec = o as? FieldSpec, let docs = spec.description {
            let comment = String.indent("// \(docs)\n", i: indentLevel)
            _out.appendContentsOf(comment.characters)
        } else if let spec = o as? MethodSpec {
            guard spec.description != nil || spec.parameters.count > 0 else {
                return
            }

            var specDoc = "" as String

            let firstline = String.indent("/**\n", i: indentLevel)
            let lastline = String.indent("*/\n", i: indentLevel)
            let indentedDocs = PoetUtil.fmap({ String.indent($0 + "\n", i: self.indentLevel + 1) }, a: spec.description)

            specDoc.appendContentsOf(firstline)
            if indentedDocs != nil {
                specDoc.appendContentsOf(indentedDocs!)
            }

            var first = true
            spec.parameters.forEach { p in
                if first && spec.description != nil {
                    specDoc.appendContentsOf("\n")
                } else if !first {
                    specDoc.appendContentsOf("\n\n")
                }
                first = false

                var paramDoc = ":param:    \(p.name)"
                if let desc = p.description {
                    paramDoc.appendContentsOf(" \(desc)")
                }
                specDoc.appendContentsOf(String.indent(paramDoc, i: indentLevel + 1))
            }
            specDoc.appendContentsOf("\n")
            specDoc.appendContentsOf(lastline)
            _out.appendContentsOf(specDoc.characters)
        }
    }

    public func emitModifiers(modifiers: Set<Modifier>) {
        guard modifiers.count > 0 else {
            _out.appendContentsOf(String.indent("", i: indentLevel).characters)
            return
        }

        let modListStr = Array(modifiers).map { m in
            return m.rawValue
        }.joinWithSeparator(" ") + " "

        _out.appendContentsOf(String.indent(modListStr, i: indentLevel).characters)
    }

    public func emit(codeBlock: CodeBlock) -> CodeWriter {
        var first = true
        codeBlock.emittableObjects.forEach { either in
            switch either {
            case .Right(let cb):
                self.emitNewLine()
                self.emitWithIndentation(cb)
            case .Left(let emitObject):
                switch emitObject.type {
                case .Literal:
                    self.emitLiteral(emitObject.any, first: first)
                case .BeginStatement:
                    self.emitBeginStatement()
                case .EndStatement:
                    self.emitEndStatement()
                case .NewLine:
                    self.emitNewLine()
                case .IncreaseIndentation:
                    self.indent()
                case .DecreaseIndentation:
                    self.unindent()
                case .CodeLine:
                    self.emitNewLine()
                    self.emitWithIndentation(emitObject.any as! Literal)
                case .Emitter:
                    self.emitEmitter(emitObject.any, first: first)
                }
                first = false
            }
        }
        return self
    }

    public func emit(type: EmitType, any: Any? = nil) -> CodeWriter {
        let cbBuilder = CodeBlock.builder()
        cbBuilder.addEmitObject(type, any: any)
        return self.emit(cbBuilder.build())
    }

    private func emitLiteral(o: Any?, first: Bool = false) {
        if let _ = o as? TypeSpec {
            // Dunno
        } else if let literalType = o as? Literal {
            var lv = literalType.literalValue().characters
            if !first { lv.insert(" ", atIndex: lv.startIndex) }
            _out.appendContentsOf(lv)
        } else if let str = o as? String {
            _out.appendContentsOf(str.characters)
        }
    }

    private func emitEmitter(o: Any?, first: Bool = true) {
        if let emitter = o as? Emitter {
            if !first { _out.append(" ") }
            emitter.emit(self)
        }
    }

    public func emitInheritance(superType: TypeName?, superProtocols: [TypeName]?) -> CodeWriter {
        var inheritance = ": "
        if let st = superType {
            inheritance += st.literalValue()
            if let sp = superProtocols where sp.count > 0 {
                inheritance += ", "
                inheritance = emitProtocolInheritance(superProtocols, output: inheritance)
            }
            _out.appendContentsOf(inheritance.characters)
        } else if let sp = superProtocols where sp.count > 0 {
            inheritance = emitProtocolInheritance(superProtocols, output: inheritance)
            _out.appendContentsOf(inheritance.characters)

        }

        return self
    }

    private func emitProtocolInheritance(superProtocols: [TypeName]?, output: String) -> String {
        -> String
    {
        var retVal = output
        if let sp = superProtocols {
            sp.forEach { protocolType in
                var literal = protocolType.literalValue()
                let spacer = ", ".characters
                literal.insertContentsOf(spacer, at: literal.endIndex)
                retVal += literal
            }

            retVal.removeRange(output.endIndex.predecessor().predecessor()..<output.endIndex)
        }
        return retVal
    }

    private func emitBeginStatement() {
        let begin = " {"
        _out.appendContentsOf(begin.characters)
        indent()
    }

    private func emitEndStatement() {
        let newline = "\n"
        unindent()
        let endBracket = String.indent("}", i: indentLevel)
        let end = newline + endBracket
        _out.appendContentsOf(end.characters)
    }

    public func emitNewLine() {
        _out.append("\n")
    }

    private func emitIndentation() {
        _out.appendContentsOf(String.indent("", i: indentLevel).characters)
    }

    public func emitWithIndentation(cb: CodeBlock) {
        self.emitIndentation()
        emit(cb)
    }

    public func emitWithIndentation(any: Literal) {
        self.emitIndentation()
        self.emitLiteral(any, first: true)
    }

    public func emitSpecs(specs: [PoetSpec]) {
        _out.appendContentsOf((specs.map { spec in
            spec.toString()
        }).joinWithSeparator("\n\n").characters)
        emitNewLine()
    }
}

extension String {
    private static let indentSpacing = ("    ").characters

    private static func indent(s: String, i: Int) -> String {
        var retVal = s
        i.times {
            retVal.insertContentsOf(String.indentSpacing, at: s.startIndex)
        }
        return retVal
    }
}

extension Int {
    private func times(fn: () -> Void) {
        for _ in 0..<self {
            fn()
        }
    }
}

